# 第一部分-基础篇


## 目录：
<!-- GFM-TOC -->
* [00 综](#00-综)
* [01 起步](#01-起步)
* [02 变量和简单数据类型](#02-变量和简单数据类型)
* [03 列表简介](#03-列表简介)
* [04 操作列表](#04-操作列表)
* [05 if语句](#05-if语句)
* [06 字典](#06-字典)
* [07 用户输入和while循环](#07-用户输入和while循环)
* [08 函数](#08-函数)
* [09 类](#09-类)
* [10 文件和异常](#10-文件和异常)
* [11 测试代码](#11-测试代码)
<!-- GFM-TOC -->


## 说明
- 笔记文件为.ipybn格式，内含全部代码及相应的笔记
- .ipynb文件若加载失败，可使用此链接打开 [https://nbviewer.jupyter.org/github/...]
  - 例如：https://nbviewer.jupyter.org/github/anliux/Python_Crash_Course/blob/master/src/PartI_Basics/A_Basics_Note.ipynb

# 00 综
- [《综》](https://github.com/anliux/Python_Crash_Course/blob/master/src/PartI_Basics/A_Basics_Note.ipynb)
- 各章汇总

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->


# 01 起步
- [第1章笔记]()
- 知识点：
  - 打印hello world：`print('要打印的内容')`
  - 注意点：单双引号均可，没有分号。
  - 打印的参数化：`print('min=%d' %min(digits))`
  - 换行：\n放在引号内打印 -- `print('\n')`
  - 制表符：\t放在引号内打印 -- `print('\t')`

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 02 变量和简单数据类型
- [第2章笔记]()
- 知识点：
  - 汇总：
    - 认识变量、变量名规则、单双引号、字符串（大小写、拼接、空白）、数字（简单计算-除法、次方）、注释（单行多行）
  - python变量名：
    - 大写无妨，尽量用小写；
    - 字母数字下划线，数字不能开头，中间不能空格，并且慎用小写字母L和大写字母O(与数字0,1非常相似)
  - Python约定的文件名：
    - 使用小写字母和下划线
  - 引号：
    - 单引号双引号均可，灵活使用有助于撇号的使用，单双均可在外。
    - 单双引号的灵活使用：普通用单；双嵌套单，英语中常用的缩写一撇等等
  - 字符串：（大小写、拼接、空白）
    - 格式：`变量.方法名()`
    - title() - 改为首字母大写、其余小写
    - upper() - 改为所有字母大写
    - lower() - 改为所有字母小写
    - + ：拼接字符串
    - 制表符：\t
    - 换行： \n
    - strip() - 删除空白
    - rstrip() - 删除右边的空白
    - lstrip() - 删除左边的空白
  - 数字：（简单计算-除法、次方）
    - py3的float不能精确显示（例如：0.1 + 0.2=0.30000000000000004）
    - 整数相除，结果为float类型（Python2的整数相除为int型，同其他语言）
    - 两个星号 * ：乘方，相当于^
    - 用+号连接str和int时，将int转为str：当int x, str(x)后在加号连接
  - Python之禅
    - 美胜于丑。
    - 显式优于隐式。
    - 简单胜于复杂。
    - 复杂总比复杂好。
    - 平的比嵌套的好。
    - 稀疏胜于稠密。
    - 可读性计数。
    - 特殊情况不足以打破规则。
    - 尽管实用性胜过纯洁性。
    - 错误永远不会悄悄地过去。
    - 除非明确沉默。
    - 面对歧义，拒绝猜测的诱惑。
    - 应该有一种——最好只有一种——显而易见的方法来做到这一点。
    - 不过，如果不是荷兰语的话，这种方式一开始可能并不明显。
    - 现在总比没有好。
    - 虽然从来没有比现在更好。
    - 如果实现很难解释，那是个坏主意。
    - 如果实现很容易解释，这可能是一个好主意。
    - 名称空间是一个非常好的主意——让我们做更多的事情吧！

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 03 列表简介
- [第3章笔记]()
- 知识点：
  - 汇总：列表的认识、创建、访问单个元素、修改、添加、删除、字母表排序、反转排序、求列表长度、索引注意事项
  - 认识列表：
    - 用方括号（[ ] ）来表示列表，并用逗号来分隔其中的元素，print时包括方括号、引号、逗号等
    - 由一系列按特定顺序排列的元素组成; 可以将任何东西加入列表中
  - 创建和访问列表：
    - 列表的格式：listname = [ , , , , ] --- 方括号，逗号隔开
    - 列表的访问：listname[n] -- 按索引n访问列表
    - 索引从0开始（同数组），负数表示倒数第几个
  - 修改、添加、删除列表元素
    - 修改：listname[n] = '新' -- 将索引n对应的元素换位'新'
    - 添加：listname.append('新') -- 将'新'添加到list的末尾
      - 动态地创建列表：先创建空列表，然后一系列append添加 -- listname=[] \\ listname.append('新') \\ listname.append('xxx')
      - 注：append不能连续使用，只能一个一个append，否则报错。
    - 插入：listname.insert(n, '新') -- 在listname的索引n处插入新元素'新'
    - 删除：del语句；pop()方法；remove()方法
      - pop有返回值，remove没有返回值
      - del listname[n]：知道要删除的元素在列表中的位置时使用。删除后无法再访问它。
      - a = listname.pop()：类似弹栈，弹出最后一个，并且返回该元素的值；弹出后仍能使用或访问这个值
      - a = listname.pop(n)：弹出索引n对应的元素；弹出后仍能使用
      - listname.remove('列表中某元素')：只知道要删除元素的值，不知道索引时；移除列表中某个值的第一个匹配项；没有返回值
  - 列表的各种排序
    - 各种方式的排序：sort(); sorted(); reverse()
    - listname.sort()：永久性排序，字母表顺序，a前z后，大写前小写后
    - listname.sort(reverse = True)：永久性排序，字母表逆序
    - sorted(listname)：临时性排序，字母表顺序，可赋值给变量后使用
    - sorted(listname, reverse = True)：临时性排序，字母表逆序
    - listname.reverse()：永久性修改，但随时可以恢复；倒着打印，注意是反转列表顺序，与字母表顺序无关
    - len(listname)：返回列表长度，可赋值给变量后使用
  - 索引：
    - 1、索引从0开始
    - 2、‘-1’在任何时候都可以用来指向最后一个元素，除非列表为空才报错
    - 3、发生索引错误却找不到解决方法时，可将列表或其长度打印出来，可以与自己以为的截然不同

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 04 操作列表
- [第4章笔记]()
- 知识点：
  - 汇总：
    - for循环、缩进注意点、数值列表创建、数学统计（最值、求和）、列表解析、列表切片、元组、代码格式优化
  - for循环遍历：
    - 刚开始使用循环时请牢记，对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。
    - 如果列表包含一百万个元素，Python就重复执行指定的步骤一百万次，且通常速度非常快。
    - 格式：for n-任意名字 in listname: 某语句
    - 示例：`for magician in magicians:     print(magician)`
  - 避免缩进错误:
    - Python根据缩进来判断代码行与前一个代码行的关系
    - 常见错误：
      - 1-忘记缩进
      - 2-忘记缩进额外的代码行
      - 3-不必要的缩进
      - 4-循环后不必要的缩进
      - 5-遗漏冒号（python有冒号，无分号，用缩进代替大括号，注意别混淆了）
  - 数值列表：
    - range(start, stop, step)：创建一个整数列表，一般用在 for 循环中
      - 例如：`for value in range(1,5): #生成1-4`
    - range()：默认从0开始，默认step为1，这两个都可以省略(step优先省略)，stop必须有，不包括stop本值
    - list(range(n))：将range()的结果直接转换为列表，可存储在变量中以后使用
      - 例如：`numbers = list(range(1,6))`，打印numbers结果为：[1, 2, 3, 4, 5]
    - 用range()创建任意数据集：新建空列表--for循环-append
  - 数学统计：
    - min(listname)-最小值；
    - max(listname)-最大值；
    - sum(listname)-求和
  - 列表解析：
    - 将 for 循环和创建新元素的代码合并成一行，并自动附加新元素。
    - 创建列表： `listname = [value计算或表达式 for value in range(n)]`
    - 代码示例：`squares = [value**2 for value in range(1,11)]`，打印结果为：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
  - 列表切片：
    - 切片：m n -- 索引值 
    - 端点值：左闭右开，从0开始，包含第一个索引值，不包含第二个索引值。
    - listname[m:n] -- 从索引值m处取到索引n的前一个元素（第m-1个到第n个）
    - listname[:n] -- 没有指定m时，默认从列表第一个元素开始
    - listname[m:] -- 没有指定n时，默认取到列表的最后一个元素
    - listname[-m:] -- m或n为负数时，从倒数第三位取到最后一个元素
    - listname[:] -- 取所有元素（是全新副本不是关联，相当于复制但区别于copy deepcopy等等）
      - 注：浅拷贝和深拷贝涉及到改变对本体的影响。
      - 参考：[Python-直接赋值、浅拷贝和深度拷贝解析](https://www.cnblogs.com/anliux/p/12834845.html)
  - 元组：
    - 列表：适合存储可能变化的数据集，使用方括号标识
      - 考点：列表不可作为字典的key，键要求唯一、不可变
    - 元组：不可变的列表称为元组，使用圆括号标识
      - 相比列表，元组是更简单的数据结构。如需存储的一组值在程序的整个生命周期内都不变，可使用元组
    - 格式：tuplename = ( , , , )
      - 索引值从0开始，由`变量名[index]`的格式获取
    - 不可以修改元组的值：tuplename[n] = m -- 会报错
    - 虽然不可以修改元组，但是可以对存储元组的变量重新赋值
      - dimensions = (200,50)
      - dimensions[0] = 400 # 报错
      - dimensions = (400,50) # 顺利改变dimensions的值
  - 格式设置指南：
    - Python改进提案 （Python Enhancement Proposal，PEP）
    - 缩进：4个空格为一级缩进
    - 行长：建议每行不超过80字符
    - 空行：python解释器不关心但影响可读性，尽量合理
    - 其他  
    
<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 05 if语句
- [第5章笔记]()
- 知识点：
  - 汇总：
    - if语句，if-else，if-elif，多个if，各种if嵌套，
    - 条件测试（布尔表达式），比较数值大小，多个条件（and，or），
    - 检测特定值是/不包含在列表中/列表是否为空/一个列表是否在另一个列表中，
    - if格式（空格增加可读性）
  - if语句格式：
    - `if xxx: xxx else: xxx`
    - 示例：` if car == 'bmw':    print(car.upper())`
  - 条件测试(布尔表达式)
    - 每条 if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试
    - if 条件测试(布尔表达式，就是一个为True 或者 False的表达式)
    - 数值大小比较：正常比较，如> >= < <=
      - 注：== 检查是否相等时考虑大小写，可以使用`变量名.lower()`等来消除大小写的影响。
    - 检查多个条件：and 或者 or组合，符合数学中的“与”和“或”的规则
    - 检查特定值是否包含在列表中: 'x' in list_name - 结果：True or False
    - 检查特定值是否不包含在列表中：关键字 not in - 'x' not in list_name - 结果：True or False，不包含时返回True
  - if语句结构：
    - if-else结构：非此即彼
    - if-elif-...-else结构: if嵌套
    - if... if... if...：测试多个条件，即不同于if-else语句，符合多个if条件时使用。
  - 使用if语句处理列表：
    - 检查特殊元素：for a in listname:  if a == 'sth':  (如果b列表中包含sth，就怎样)
    - 检查列表不是空的：if listname: ... 
    - 检查一个列表a是否在另一个列表b中：for a in a_list: if a in b_list: ..
  - 设置if语句的格式：
    - 在诸如== 、>= 和<= 等比较运算符两边各添加一个空格，例如，if age < 4: 要比if age<4: 好
  
<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 06 字典
- [第6章笔记]()
- 知识点：
  - 汇总：
    - 字典，键唯一值不要求，字典无序，访问，添加，修改，删除，语句过长拆分，for遍历的三种方法，字典和列表的各种相互嵌套
  - 一个简单的字典
    - 格式：dictname = {'键': '值', '键': '值', '键': '值', … '键': '值'}
    - 访问：dictname['键']，可赋值给变量存储后使用
    - 考点：
      - 键必须是唯一的，但值则不必。
      - 值可以取任何数据类型，但键必须是不可变的
      - 键：如字符串，数字或元组。
      - 值：可将python中任何对象用作字典中的值，比如数字、字符串、列表、字典等。
  - 使用字典：
    - 字典：‘键值对’，放在花括号里{}，每个键都与一个值相关联，可使用键来访问与之相关联的值。
    - 键-值：两个相关联的值，指定键时，返回与之相关联的值；键和值冒号分隔，键-值对之间逗号分隔。
    - 在一个字典中，键值对的数量没有限制
    - 访问字典中的值：dictname['键']，返回相关联的值
    - 字典是无序的，而列表是有序的（可通过索引0-n进行访问，添加也是append到末尾，insert到对应位置）
    - 添加键值对：dictname['键'] = '值'，然后就将这对键值对添加到字典中的任意位置了
      - 注：排列与添加顺序无关，字典是无序的
    - 创建空字典后添加：dictname = {} 然后 dictname['键'] = '值'....进行添加
    - 修改字典中的元素：dictname['键'] = '新值'
    - 删除字典中的元素：del dictname['键'] -- `del 字典名[键]`，就可以将该字典中的键值对删除
    - 过长的一行语句的拆分，如print(XXX ，+ \\ + 下一行四个空格+内容)
  - 遍历字典:
    - 遍历：for循环
      - 1-items()方法：所有键-值对
      - 2-keys()方法：所有键（可省略，加上使代码可读性更好）
      - 3-values()方法：所有值；
      - 4-set()函数：剔除重复元素
    - items() 方法：
      - 以列表形式返回可遍历的(键, 值) 元组数组（并非直接的列表，若要返回列表值还需调用list函数）
      - items() 方法返回值：dict_items([('last', 'fermi'), ... , ('username', 'efermi')]) -- 元组里的列表里的以键值对为单位的元组
      - items() + for循环：
        - 格式：for a, b in list.items():... 无论如何命名，a和b一前一后分别对应键和值
    - keys() 方法：
      - 返回字典中的键
      - keys() + for循环：
        - 格式：for a in dictname.keys(): ... 
          - 提取字典dictname中的所有键，并依次将其存储到变量a中；遍历字典默认遍历键，keys()可省略
        - 可在for循环中对返回的键进行排序。可使用函数sorted()来获取特定顺序排列的键列表的副本
          - 格式：`for name in sorted(favorite_languages.keys()): xxx`
    - values() 方法：
      - 返回一个值列表，不包含任何键。
      - values() + for循环：
        - 格式：for a in dictname.values(): ... for语句提取字典中的每个值，并将它们依次存储到变量a中。
        - 注：字典无序，因此返回的值无序。
    - set()方法：
      - (起因：键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。)
      - 使用集合（set）可剔除重复项 - 类似于列表，但每个元素都是独一无二的
      - set()：对包含重复元素的列表调用set()，可找出列表中独一无二的元素，并使用这些元素创建一个集合
      - 格式：for a in set(dictname.values()): ...
      - 注：字典无序，因此返回的值无序。
  - 嵌套：
    - 将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套
    - 可以在列表中嵌套字典、在字典中嵌套列表、在字典中嵌套字典
    - 在列表中嵌套字典：
      - 格式：dict_1 = {} dict_2 = {} dict_3 = {} listname = [dict_1, dict_2, dict_3]
    - 在字典中嵌套列表：当需要在字典中将一个键关联到多个值时
      - 格式：dictname = {'键':'值', '键': [a, b, c, ... , m]} --- 例子中第二个键关联到a-m等多个值
      - 此时若用for循环遍历字典，需要两层for循环，因为键值对中的值有多个元素，因此需要for循环来遍历取出。
    - 在字典中嵌套字典：
      - 格式：dictname = { '键1': {字典1}, '键2': {字典2}, ... , '键n': {字典n} }

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 07 用户输入和while循环
- [第7章笔记]()
- 知识点：
  - 汇总：
    - input()，求模运算%，
    - while循环，标志(封装的布尔表达式)，break退出循环，
    - while循环处理字典和列表（列表间移动元素、删除列表中多次出现的元素、input填充字典）
  - 函数input()的工作原理：
    - 让程序暂停运行，等待用户输入一些文本。获取用户输入后，将其存储在一个变量中。回车继续运行。
    - input(参数)：暂停程序，展示括号中的参数，等待用户输入，回车继续运行，并返回输入的值
      - 例如：`message = input('Tell me something, and I will repeat it back to you: ')`
    - input()：默认返回值是字符串，可用int()将str转为数值型，可将存储input返回值的变量放在int()中，或直接int(input())
  - 求模运算符：
    - % ：将两数相除并返回余数 
    - 格式：m % n
  - while循环概述：
    - for循环：用于针对集合中的每个元素都一个代码块
    - while循环：不断运行，直到指定的条件不满足为止
      - while循环格式：while 语句: xxx xxx .. xx(可内含多条语句)
    - 标志：定义一个变量，用于判断整个程序是否处于活动状态，这个变量称为‘标志’
      - 标志的好处：while只需检查标志一个条件，并将所有测试 (是否发生了应将标志设置为False的事件) 都放在其他地方，使程序更为整洁
      - 代码示例：`active = True \\ while active:  \\  message = input(prompt) \\  if message == 'quit': active = False`
    - break退出循环：立即退出循环，不再运行循环中余下的代码，也不管条件测试的结果如何
      - break循环：可以用在任何Python循环中，例如，退出遍历列表或字典的for循环
    - continue：
      - 在循环中使用continue：返回到循环开头，并根据条件测试结果决定是否继续执行循环
      - 场景：当符合某if条件时，直接结束本次循环并跳到下一次循环的判断阶段，即跳过continue后的语句。
  - 使用while循环来处理列表和字典：
    - 在列表之间移动元素： 
      - 示例：while list_1: a = list_1.pop() list_2.append(a) --- 可将list_1中的元素逐渐移动到list_2中
    - 删除一个列表中多次出现的元素：
      - 示例：while 'xx' in listname: listname.remove('xx')
      - 代码示例：`while 'cat' in pets: \\  pets.remove('cat')`
    - 使用用户输入填充字典：
      - 创建空字典 \\ 标志=True \\ while 标志: xx xxx xx input \\ if xx: 标志 = False

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 08 函数
- [第8章笔记]()

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 09 类
- [第9章笔记]()

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 10 文件和异常
- [第10章笔记]()

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



# 11 测试代码  
(注：各种报错，待整理)
- [第11章笔记]()

<!-- GFM-TOC -->
- [返回目录](#目录)
<!-- GFM-TOC -->



### END
